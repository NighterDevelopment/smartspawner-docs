---
// src/components/ContributorList.astro
import fs from 'fs/promises';
import path from 'path';

interface Contributor {
  login: string;
  avatar_url: string;
  html_url: string;
  contributions: number;
  type: string;
}

interface CacheData {
  contributors: Contributor[];
  timestamp: number;
  etag?: string;
  lastSuccessfulFetch?: number;
  apiCallsRemaining?: number;
  rateLimit?: {
    limit: number;
    remaining: number;
    reset: number;
  };
}

interface Props {
  repository?: string;
  limit?: number;
  excludeUsernames?: string[];
  cacheTime?: number; // Cache time in minutes
  maxStaleTime?: number; // Maximum time to use stale cache in minutes
  fallbackData?: Contributor[]; // Static fallback data
}

const { 
  repository = 'ptthanh02/SmartSpawner', 
  limit = 50,
  excludeUsernames = ['dependabot', 'Copilot'],
  cacheTime = 120, // Cache for 2 hour by default
  maxStaleTime = 24 * 60, // Use stale cache for up to 24 hours
  fallbackData = []
} = Astro.props;

const GITHUB_API_URL = `https://api.github.com/repos/${repository}/contributors`;
const CACHE_DIR = path.join(process.cwd(), 'cache');
const CACHE_FILE = path.join(CACHE_DIR, `contributors-${repository.replace('/', '-')}.json`);

// Static fallback contributors
const STATIC_FALLBACK: Contributor[] = fallbackData.length > 0 ? fallbackData : [
  // static contributors here as fallback
  // {
  //   login: 'ptthanh02',
  //   avatar_url: 'https://github.com/ptthanh02.png',
  //   html_url: 'https://github.com/ptthanh02',
  //   contributions: 100,
  //   type: 'User'
  // }
];

// Ensure cache directory exists
async function ensureCacheDir() {
  try {
    await fs.mkdir(CACHE_DIR, { recursive: true });
  } catch (error) {
    console.warn('Could not create cache directory:', error);
  }
}

// Read cache from file
async function readCache(): Promise<CacheData | null> {
  try {
    const cacheContent = await fs.readFile(CACHE_FILE, 'utf8');
    return JSON.parse(cacheContent);
  } catch (error) {
    console.warn('Could not read cache file:', error);
    return null;
  }
}

// Write cache to file
async function writeCache(data: CacheData): Promise<void> {
  try {
    await ensureCacheDir();
    await fs.writeFile(CACHE_FILE, JSON.stringify(data, null, 2));
    console.log('Cache updated successfully');
  } catch (error) {
    console.warn('Could not write cache:', error);
  }
}

// Check if cache is valid (not stale)
function isCacheValid(cache: CacheData, cacheTimeMinutes: number): boolean {
  const now = Date.now();
  const cacheAge = now - cache.timestamp;
  const maxAge = cacheTimeMinutes * 60 * 1000; // Convert minutes to milliseconds
  return cacheAge < maxAge;
}

// Check if we can use stale cache (better than no data)
function canUseStaleCache(cache: CacheData, maxStaleTimeMinutes: number): boolean {
  const now = Date.now();
  const cacheAge = now - cache.timestamp;
  const maxStaleAge = maxStaleTimeMinutes * 60 * 1000;
  return cacheAge < maxStaleAge;
}

// Check if we should avoid API call due to rate limiting
function shouldAvoidApiCall(cache: CacheData | null): boolean {
  if (!cache?.rateLimit) return false;
  
  const now = Date.now();
  const resetTime = cache.rateLimit.reset * 1000; // GitHub reset time is in seconds
  
  // If rate limit hasn't reset and we have very few remaining calls, avoid API
  if (now < resetTime && cache.rateLimit.remaining < 5) {
    console.log('Avoiding API call due to low rate limit remaining');
    return true;
  }
  
  return false;
}

// Parse rate limit headers
function parseRateLimit(response: Response): CacheData['rateLimit'] | undefined {
  const limit = response.headers.get('x-ratelimit-limit');
  const remaining = response.headers.get('x-ratelimit-remaining');
  const reset = response.headers.get('x-ratelimit-reset');
  
  if (limit && remaining && reset) {
    return {
      limit: parseInt(limit),
      remaining: parseInt(remaining),
      reset: parseInt(reset)
    };
  }
  
  return undefined;
}

// Fetch contributors with enhanced cache support
async function fetchContributors(): Promise<{ 
  contributors: Contributor[], 
  fromCache: boolean,
  isStale: boolean,
  error?: string 
}> {
  const cache = await readCache();
  
  // Check if we have valid cached data
  if (cache && isCacheValid(cache, cacheTime)) {
    console.log('Using fresh cached contributors data');
    return { contributors: cache.contributors, fromCache: true, isStale: false };
  }

  // Check if we should avoid API call due to rate limiting
  if (shouldAvoidApiCall(cache)) {
    if (cache && canUseStaleCache(cache, maxStaleTime)) {
      console.log('Using stale cache due to rate limit restrictions');
      return { 
        contributors: cache.contributors, 
        fromCache: true, 
        isStale: true,
        error: 'Rate limited - using cached data'
      };
    }
  }

  // Prepare headers
  const headers: Record<string, string> = {
    'User-Agent': 'SmartSpawner-Website/1.0',
    'Accept': 'application/vnd.github.v3+json'
  };
  
  // Use GitHub token if available
  if (import.meta.env.GITHUB_TOKEN) {
    headers['Authorization'] = `Bearer ${import.meta.env.GITHUB_TOKEN}`;
  }

  // Use ETag for conditional requests if available
  if (cache?.etag) {
    headers['If-None-Match'] = cache.etag;
  }

  try {
    console.log('Attempting to fetch contributors from GitHub API...');
    const response = await fetch(GITHUB_API_URL, { 
      headers,
      // Add timeout to prevent hanging
      signal: AbortSignal.timeout(10000) // 10 second timeout
    });
    
    const rateLimit = parseRateLimit(response);
    console.log('Rate limit status:', rateLimit);
    
    // If 304 Not Modified, use cached data but update timestamp
    if (response.status === 304 && cache) {
      console.log('Contributors data not modified, refreshing cache timestamp');
      const updatedCache = { 
        ...cache, 
        timestamp: Date.now(),
        rateLimit: rateLimit || cache.rateLimit
      };
      await writeCache(updatedCache);
      return { contributors: cache.contributors, fromCache: true, isStale: false };
    }
    
    if (response.ok) {
      const data = await response.json();
      const etag = response.headers.get('etag');
      
      // Process contributors data
      let contributors: Contributor[] = data.filter((contributor: Contributor) => 
        contributor.type !== 'Bot' &&
        !excludeUsernames.some(excluded => 
          contributor.login.toLowerCase().includes(excluded.toLowerCase())
        )
      );

      contributors.sort((a, b) => b.contributions - a.contributions);
      contributors = contributors.slice(0, limit);

      // Cache the result
      const cacheData: CacheData = {
        contributors,
        timestamp: Date.now(),
        lastSuccessfulFetch: Date.now(),
        etag: etag || undefined,
        rateLimit
      };
      
      await writeCache(cacheData);
      console.log('Fetched and cached new contributors data');
      
      return { contributors, fromCache: false, isStale: false };
    } 
    
    // Handle rate limiting
    else if (response.status === 403) {
      const errorText = await response.text().catch(() => '');
      console.warn('GitHub API rate limit exceeded');
      
      // Update cache with rate limit info
      if (cache) {
        const updatedCache = { 
          ...cache, 
          rateLimit: rateLimit || cache.rateLimit 
        };
        await writeCache(updatedCache);
      }
      
      // Use stale cache if available
      if (cache && canUseStaleCache(cache, maxStaleTime)) {
        console.log('Using stale cache due to rate limit');
        return { 
          contributors: cache.contributors, 
          fromCache: true, 
          isStale: true,
          error: 'Rate limit exceeded - using cached data'
        };
      }
      
      throw new Error(`Rate limit exceeded. ${errorText.includes('rate limit') ? 'Try again later.' : errorText}`);
    }
    
    // Handle other HTTP errors
    else {
      const errorText = await response.text().catch(() => '');
      throw new Error(`GitHub API responded with ${response.status}: ${response.statusText}. ${errorText}`);
    }
  } catch (error) {
    console.error('Error fetching from GitHub API:', error);
    
    // If we have stale cached data, use it as fallback
    if (cache && canUseStaleCache(cache, maxStaleTime)) {
      console.warn('Using stale cache as fallback due to API error');
      return { 
        contributors: cache.contributors, 
        fromCache: true, 
        isStale: true,
        error: `API error - using cached data: ${error instanceof Error ? error.message : String(error)}`
      };
    }
    
    // Ultimate fallback to static data if available
    if (STATIC_FALLBACK.length > 0) {
      console.warn('Using static fallback data');
      return { 
        contributors: STATIC_FALLBACK.slice(0, limit), 
        fromCache: false, 
        isStale: true,
        error: `Using fallback data: ${error instanceof Error ? error.message : String(error)}`
      };
    }
    
    throw error;
  }
}

let contributors: Contributor[] = [];
let error: string | null = null;
let fromCache = false;
let isStale = false;
let cacheWarning: string | null = null;

try {
  const result = await fetchContributors();
  contributors = result.contributors;
  fromCache = result.fromCache;
  isStale = result.isStale;
  if (result.error) {
    cacheWarning = result.error;
  }
} catch (err) {
  error = `Error loading contributors: ${err instanceof Error ? err.message : String(err)}`;
  console.error(error);
}
---

<div class="contributor-section">
  <div class="contributor-header">
    <h2 class="contributor-title">
      <svg class="contributor-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
        <circle cx="9" cy="7" r="4"/>
        <path d="m22 21-3-3m0 0a5 5 0 1 0-7-7 5 5 0 0 0 7 7Z"/>
      </svg>
      Contributors
    </h2>
    
    <div class="status-indicators">
      {fromCache && (
        <div class={`cache-indicator ${isStale ? 'stale' : 'fresh'}`} title={isStale ? "Data is from cache (may be outdated)" : "Data loaded from cache (up to date)"}>
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
            <path d="M21 3v5h-5"/>
            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
            <path d="M3 21v-5h5"/>
          </svg>
          {isStale ? 'Stale Cache' : 'Cached'}
        </div>
      )}
      
      {cacheWarning && (
        <div class="warning-indicator" title={cacheWarning}>
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
            <path d="M12 9v4"/>
            <path d="m12 17 .01 0"/>
          </svg>
          Warning
        </div>
      )}
    </div>
  </div>
  
  <p class="contributor-description">
    We appreciate all contributions to SmartSpawner! Here are the amazing people who have helped make this project possible:
  </p>

  {contributors.length > 0 ? (
    <div class="contributor-grid">
      {contributors.map((contributor) => (
        <a 
          href={contributor.html_url} 
          class="contributor-card" 
          target="_blank" 
          rel="noopener noreferrer"
          title={`${contributor.login} - ${contributor.contributions} contributions`}
        >
          <div class="contributor-avatar-wrapper">
            <img 
              src={contributor.avatar_url} 
              alt={`${contributor.login} avatar`}
              class="contributor-avatar"
              loading="lazy"
              onerror="this.src='https://github.com/identicons/default.png'"
            />
            <div class="contributor-badge">
              {contributor.contributions}
            </div>
          </div>
          <div class="contributor-details">
            <h3 class="contributor-name">{contributor.login}</h3>
            <p class="contributor-stats">
              {contributor.contributions} contribution{contributor.contributions !== 1 ? 's' : ''}
            </p>
          </div>
        </a>
      ))}
    </div>
  ) : error ? (
    <div class="contributor-error">
      <p>Unable to load contributors at this time.</p>
      <details class="error-details">
        <summary>Error details</summary>
        <p>{error}</p>
        <p class="error-suggestion">
          This is usually due to GitHub API rate limiting. The data will be automatically refreshed when the rate limit resets.
        </p>
      </details>
    </div>
  ) : (
    <div class="contributor-loading">
      <p>Loading contributors...</p>
    </div>
  )}
</div>

<style>
  .contributor-section {
    margin: 3rem 0;
    padding: 0;
  }

  .contributor-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .contributor-title {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 1.875rem;
    font-weight: 700;
    color: var(--sl-color-white);
    margin: 0;
    line-height: 1.2;
  }

  .contributor-icon {
    color: var(--sl-color-blue);
    flex-shrink: 0;
  }

  .status-indicators {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .cache-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: 0.8rem;
    cursor: help;
    border: 1px solid;
  }

  .cache-indicator.fresh {
    background: var(--sl-color-green-low);
    border-color: var(--sl-color-green);
    color: var(--sl-color-green);
  }

  .cache-indicator.stale {
    background: var(--sl-color-orange-low);
    border-color: var(--sl-color-orange);
    color: var(--sl-color-orange);
  }

  .warning-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.75rem;
    background: var(--sl-color-orange-low);
    border: 1px solid var(--sl-color-orange);
    border-radius: 1rem;
    font-size: 0.8rem;
    color: var(--sl-color-orange);
    cursor: help;
  }

  .cache-indicator svg,
  .warning-indicator svg {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }

  .contributor-description {
    color: var(--sl-color-gray-2);
    font-size: 1.1rem;
    margin-bottom: 2rem;
    line-height: 1.6;
  }

  .contributor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1.5rem;
  }

  .contributor-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem 1.5rem;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 1rem;
    background: var(--sl-color-black);
    text-decoration: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
  }

  .contributor-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, 
      var(--sl-color-blue), 
      var(--sl-color-purple), 
      var(--sl-color-green)
    );
    transform: scaleX(0);
    transition: transform 0.3s ease;
  }

  .contributor-card:hover {
    border-color: var(--sl-color-blue);
    background: var(--sl-color-blue-low);
    transform: translateY(-8px) scale(1.02);
    box-shadow: 
      0 20px 40px rgba(0, 0, 0, 0.3),
      0 0 0 1px rgba(135, 206, 235, 0.1);
  }

  .contributor-card:hover::before {
    transform: scaleX(1);
  }

  .contributor-avatar-wrapper {
    position: relative;
    margin-bottom: 1.25rem;
  }

  .contributor-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid var(--sl-color-gray-5);
    transition: all 0.3s ease;
  }

  .contributor-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: var(--sl-color-white);
    border-radius: 50%;
    min-width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
    border: 3px solid var(--sl-color-black);
    transition: all 0.3s ease;
  }

  :root[data-theme="light"] .contributor-badge,
  html[data-theme="light"] .contributor-badge {
    background: linear-gradient(135deg, #5a67d8, #6b46c1);
    color: #ffffff;
    border-color: #ffffff;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
  }

  .contributor-card:hover .contributor-badge {
    background: linear-gradient(135deg, #10b981, #059669);
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
  }

  .contributor-card:hover .contributor-avatar {
    border-color: var(--sl-color-blue);
    transform: scale(1.1);
  }

  .contributor-details {
    text-align: center;
    width: 100%;
  }

  .contributor-name {
    font-weight: 700;
    color: var(--sl-color-white);
    font-size: 1.125rem;
    margin: 0 0 0.5rem 0;
    line-height: 1.3;
    transition: color 0.3s ease;
  }

  .contributor-stats {
    font-size: 0.9rem;
    color: var(--sl-color-gray-3);
    margin: 0;
    line-height: 1.2;
    transition: color 0.3s ease;
  }

  .contributor-card:hover .contributor-name {
    color: var(--sl-color-blue);
  }

  .contributor-card:hover .contributor-stats {
    color: var(--sl-color-gray-1);
  }

  .contributor-error,
  .contributor-loading {
    text-align: center;
    padding: 3rem 2rem;
    color: var(--sl-color-gray-3);
    font-style: italic;
    border: 1px solid var(--sl-color-gray-6);
    border-radius: 0.5rem;
    background: var(--sl-color-gray-6);
  }

  .error-details {
    margin-top: 1rem;
    text-align: left;
  }

  .error-details summary {
    cursor: pointer;
    color: var(--sl-color-gray-2);
    font-weight: 600;
  }

  .error-details p {
    margin-top: 0.5rem;
    font-family: monospace;
    font-size: 0.875rem;
    background: var(--sl-color-gray-7);
    padding: 1rem;
    border-radius: 0.25rem;
    overflow-wrap: break-word;
  }

  .error-suggestion {
    font-style: normal !important;
    color: var(--sl-color-blue) !important;
    font-family: inherit !important;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .contributor-header {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .status-indicators {
      align-self: stretch;
      justify-content: flex-start;
    }
    
    .contributor-grid {
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 1.25rem;
    }
    
    .contributor-card {
      padding: 1.5rem 1rem;
    }
    
    .contributor-avatar {
      width: 65px;
      height: 65px;
    }
    
    .contributor-badge {
      min-width: 24px;
      height: 24px;
      font-size: 0.7rem;
    }
    
    .contributor-name {
      font-size: 1rem;
    }
    
    .contributor-stats {
      font-size: 0.85rem;
    }
  }

  @media (max-width: 480px) {
    .contributor-grid {
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 1rem;
    }
    
    .contributor-title {
      font-size: 1.5rem;
    }
    
    .contributor-description {
      font-size: 1rem;
    }
    
    .cache-indicator,
    .warning-indicator {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
    }
  }

  :root[data-dev] .cache-indicator,
  :root[data-dev] .warning-indicator {
    display: flex;
  }
</style>